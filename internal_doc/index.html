<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="Generator" content="Microsoft Word 97">
<meta name="GENERATOR" content="Mozilla/4.7 [fr] (WinNT; I) [Netscape]">
<meta name="Author" content="Alain Buhsing">
<meta name="Classification" content="Logiciel scientifique.">
<meta name="Description" content="Description du logiciel Moïra">
<meta name="KeyWords" content="Environnement de développement, Logiciel scientifique"><title>A GUI for LaBS</title></head>
<body>
&nbsp;
<table cols="2" width="100%">
<tbody>
<tr>
<td><img src="logo-cs.gif" alt="Simply Moira" style="width: 145px; height: 84px;"></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<center><a name="DebutPage"></a>
<br>
<big><big><b><font size="+3"><big><big>HexaBlock</big></big></font></b></big></big><b><font size="+3"><br>
<br>
<small>Bibliothèque de formes</small><br><small><small><br>Documentation interne du moteur</small></small><br>
</font></b></center>
<blockquote><i><span style="font-weight: bold;"></span><br>
Ce document constitue la documentation interne du composant HEXABLOCK.<br>Ce
document fait partie des sources du projet et&nbsp;est géré en
configuration Pour le mettre à jour, utiliser kompozer, disponible sur
Linux<br>
<br>
</i></blockquote>
<hr width="100%">
<p><img src="blue-ball.gif" alt="o" height="12" width="12"><b> Table of contents :</b>
<br>
&nbsp;
</p>
<center>
<table style="width: 677px; height: 108px;">
<tbody>
<tr>
<td>
<dt><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp; <a href="#Partie_1">Partie&nbsp;1 : Prévisualisation des éléments créés</a></dt>
</td>
</tr>
<tr>
<td>
<dt><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp;&nbsp;<a href="#Partie_2">Partie 2 : Nouvelles fonctions de construction</a></dt><ul><li><a href="#Partie_2">Création d'hexaèdres</a></li><li><a href="#Partie_2.2">Génération d'hexaèdres par révolution</a></li><li><a href="#Partie_2.3">Substitution d'hexaèdres</a></li></ul>
</td>
</tr>
<tr>
<td><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp; <a href="#Partie_3">Partie 3 : Bibliothèques de formes</a></td>
</tr>


<tr><td><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp; <a href="#Partie_4">Partie 4 : Evolution des associations</a></td></tr><tr><td><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp; <a href="#Partie_5">Partie 5 : Programmation d'exemples</a></td></tr></tbody>
</table>
</center>
<p><img src="blue-ball.gif" alt="o" height="12" width="12"><b> See also :</b></p><center>
<table style="width: 677px; height: 60px;">
<tbody>
<tr>
<td>
<dt><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp;&nbsp;<a href="LastNews.html"><span style="text-decoration: underline;">Last news</span></a></dt>
</td>
</tr>
<tr>
<td>
<dt><img src="green-ball.gif" alt="o" height="12" width="12"> &nbsp;&nbsp;<a href="Questions.html"><span style="text-decoration: underline;">Frequently asked questions</span></a></dt>
</td>
</tr>



</tbody>
</table>
</center>
<p></p>
<hr width="100%">
<p><a name="Partie_1"></a></p>
<p><big><img src="blue-ball.gif" alt="o" height="12" width="12"><b><font size="+1"><big> Partie 1 : prévisualisation des éléments créés</big></font></b></big></p>Pour
que SALOME puisse prévisualiser le "document" en cours de modivication,
il est nécessaire de créer une copie de l'original. L'évolution
majeure du moteur &nbsp;consiste à implémenter une fonction de
copie.&nbsp; <br><br>Ce qui revient à ajouter dans la classe Document la méthode suivante :<br><br>
<table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td>Document* copyDocument ();
</td>
</tr>
</tbody>
</table>
<br>La valeur rendue est le document copié.<br>Les éléments copiés sont les éléments
intrinsèques du document : vertices, edges, quadrangles, hexaèdres,
lois. Qui sont aussi ceux sauvegardés dans un texte XML. On ne stocke
pas les éléments intermédiaires de construction (grilles, vecteurs,
etc...).<br><br>Cette rège pourra être remise en cause si l'application interactive a besoin d'autres informations.<br><br>La copie se déroule ainsi :<br><ul><li>Chaque élément dispose d'un champ (nommé <span style="font-weight: bold;">clone</span>) qui permet de mémoriser l'adresse du dernier élément copié à partir de cet élément dans le cadre de la copie de document.</li><li>Copier&nbsp;les
éléments de bas niveau (les vertices) : méthode&nbsp;<span style="font-weight: bold;">Vertex::duplicate(Document* cible)</span>. Cette méthode ne rend pas de pointeur ; elle crée un clone du sommet courant et le mémorise sur le champ <span style="font-weight: bold;">clone</span> de la classe <span style="font-weight: bold;">Vertex</span>.</li><li>Copier&nbsp; les éléments présents de plus haut niveau dans l'ordre (edges, quads, hexas) : méthode virtuelle <span style="font-weight: bold;">EltBase::duplicate ()</span></li><ul><li>Si
un élément utilise n éléments de plus bas niveau, sa copie utilise les
copies des éléments utilisés. Il est aisé de retrouver la copie car on
en a stocké l'adresse.</li><li>Détail
: la méthode duplicate n'a pas besoin d'argument de type Document* elle
reprend le document cible des éléments de plus bas niveau..</li></ul><li>Copier les lois</li></ul>Les associations sont copiées lors de la copie de chaque élément.<br><br><br>
<a href="#DebutPage">Retour au début</a>
<hr width="100%">
<p><a name="Partie_2"></a></p>
<p><big><img src="blue-ball.gif" alt="o" height="12" width="12"></big><b><font size="+1"><big>
&nbsp;Partie 2 : Nouvelles fonctions de construction</big></font></b></p><p><big><img style="width: 12px; height: 12px;" src="green-ball.gif" alt="o"></big><b><font size="+1"><big> 2.1 Création d'Hexaèdres</big></font></b></p>
<p class="MsoNormal" style="text-align: left;" align="left">Il s'agit de construire un hexaèdre à partir de quadrangles déjà créés dans le
modèle de blocs. Cet hexaèdre est produit à partir des 4 cas suivants :</p>

<ul style="margin-top: 0cm;" type="disc"><li class="MsoNormal" style="text-align: left;">à partir de 2 quadrangles reliés ou pas,</li><li class="MsoNormal" style="text-align: left;">à partir de 3 quadrangles tous reliés,</li><li class="MsoNormal" style="text-align: left;">à partir de 4 quadrangles tous reliés,</li><li class="MsoNormal" style="text-align: left;">à partir de 5 quadrangles tous reliés.</li></ul>Les points d'entrée sont naturellement :<br><br>

<span style="font-size: 11pt; font-family: Garamond;"></span>
<table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td>Hexa* addHexa2Quads (Quad* q1,&nbsp;Quad* q2);<br>Hexa* addHexa3Quads (Quad* q1,&nbsp;Quad* q2, Quad* q3);<br>Hexa* addHexa4Quads (Quad* q1,&nbsp;Quad* q2, Quad* q3,&nbsp;Quad* q4);<br>Hexa* addHexa5Quads (Quad* q1,&nbsp;Quad* q2, Quad* q3,&nbsp;Quad* q4,&nbsp;Quad* q5);</td>
</tr>
</tbody>
</table><p>Chacun des cas amène une discussion. La démarche est la suivante :&nbsp;</p><ul><li>Les quadrangles passés en argument dans un ordre quelconque.</li><li>Un
analyseur d'intersections (classe&nbsp;<span style="font-weight: bold;">AnaQuads</span>,
définie dans
HexAnaQuads.hxx) détermine les arêtes communes aux n quadrangles passés
en argument. et mémorise ces informations qui seront transmises aux
fonctions internes, afin de ne pas répêter ces calculs d'intersection.</li><li>En fonction du nombre d'arêtes communes à chaque quadrangle, on se ramène à 7 cas.&nbsp;</li><li>Si le nombre d'arêtes communes est insuffisant, le cas est rejeté.</li><li>On nomme ces cas en se servant de la nomenclature des faces dans le projet : (A, B, C, D, E,F)</li><li></li></ul><img src="red-ball.gif" style="width: 12px; height: 12px;" alt="o">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Rappel&nbsp; :&nbsp; formalisation des Hexaèdres/Quadrangles/Vertex</span><br><br><br>Pour rappel :<br><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z=0&nbsp;&nbsp; z=1&nbsp;&nbsp;
y=0&nbsp;&nbsp; y=1&nbsp;&nbsp; x=0&nbsp; x=1<br>enum EnumHQuad&nbsp;&nbsp; {Q_A,&nbsp; Q_B,&nbsp; Q_C,&nbsp; Q_D,&nbsp; Q_E, Q_F,&nbsp; HQ_MAXI};<br></td>
</tr>
</tbody>
</table><br>La face A est opposée à B, C est opposée à D, E à F. La
position des faces&nbsp; A, C, E normales à Oz, Oy, Ox est purement
théorique. Elle améliore la visualisation. Les orientations sont en
fait&nbsp; interchangeables. On peut intervertir les couples (C,D) et
(E,F), on peut intervertir A et B, C et D, E et F, l'essentiel est
d'avoir une cohérence&nbsp; avec les autres dénominations d'edges (ac,
af, ad ...) ou de&nbsp;sommets (ace, acf, adf ...) &nbsp;et les
conventions de départ.<br><br>L'arête située la face X et la face Y est notée xy. Un sommet situé entre les 3 faces X, Y Z est noté xyz :<br><br><table style="font-family: monospace; width: 500px; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="width: 50%;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6=bde&nbsp; +----bd-----+ bdf=7<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be |&nbsp;&nbsp; <span style="font-weight: bold;">B</span>&nbsp;&nbsp;&nbsp; bf |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; |<br>&nbsp;&nbsp;&nbsp; 4=bce +----bc-----+...|...bcf=5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; de&nbsp;&nbsp;&nbsp;&nbsp; <big style="font-weight: bold;">D</big> |&nbsp;&nbsp; df<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
| <span style="font-weight: bold;">E</span> |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | F
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ce&nbsp;&nbsp; |
<span style="font-weight: bold;">C&nbsp;</span>&nbsp;&nbsp;&nbsp; cf&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^<br>&nbsp; 2=ade...|...+----ad-|---+ adf=3&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; y<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; /<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
ae&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">A</span>&nbsp;&nbsp; |
af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
| /<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|/<br>&nbsp;&nbsp;&nbsp; 0=ace +----ac-----+ acf=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----&gt;&nbsp;x<br>&nbsp;&nbsp; <br><br></td>
</tr>
</tbody>
</table><br><img src="red-ball.gif" style="width: 12px; height: 12px;" alt="o">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">La classe AnaQuads</span><br><br>Cette
classe analyse les relations topologiques existant entre plusieurs
quandrangles. Un objet de ce type est créé au début de chaque fonction
addHexaXQuads.<br><br>Le constructeur est :<br><br>

<span style="font-size: 11pt; font-family: Garamond;"></span>
<table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td>AnaQuads (Quad* q1, Quad* q2, Quad* q3=NULL, Quad* q4=NULL, Quad* q5=NULL);<br></td>
</tr>
</tbody>
</table><br>Les champs affectés lors de la construction de l'objet :<br><br><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>MawQuads </td><td>Constante égale à 5 5</td></tr><tr><td>int&nbsp;&nbsp;&nbsp; nbr_quads;</td><td>Nombre de quadrangles</td></tr><tr><td>int&nbsp;&nbsp;&nbsp; nbr_aretes;</td><td>Nombre total d'arêtes</td></tr><tr><td>Quad*&nbsp; tab_quads&nbsp; [i];</td><td>Le ième quadrangle passé en argument </td></tr><tr><td>int&nbsp;&nbsp;&nbsp; inter_nbre [i];</td><td>Nombre d'intersections du ième quadrangle</td></tr><tr><td>int&nbsp;&nbsp;&nbsp; inter_edge [i][j];</td><td>Nro d'arête de i intersectant le jème quadrangle</td></tr><tr><td>int&nbsp;&nbsp;&nbsp; inter_quad [i][j];</td><td>Nro de quadrangle présent sur la jème arete du iéme quad</td></tr></tbody></table><br><br><img src="red-ball.gif" style="width: 12px; height: 12px;" alt="o">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Création d'un hexaèdre avec deux quadrangles :&nbsp;</span>&nbsp;<ul><li>La classe AnaQuads ne détecte aucune arête commune : appel à addHexaQuadsAB</li><li>La classe AnaQuads&nbsp; détecte&nbsp;une arête commune : appel à addHexaQuadsAC</li></ul><table style="text-align: left; width: 90%;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="vertical-align: middle; text-align: center;"><p><img src="Quads_AB.png" style="width: 282px; height: 226px;" alt="En diedre"></p></td><td style="vertical-align: middle; text-align: center;"><img src="Quads_AC.png" style="width: 278px; height: 223px;" alt="Vis a vis"></td></tr><tr><td style="vertical-align: middle;">addHexa2Quads avec 2 quadrangles&nbsp; non reliés. <br>Fonction : addHexaQuadsAB</td><td style="vertical-align: middle;">addHexa2Quads avec 2 quadrangles&nbsp;&nbsp; reliés. <br>Fonction : addHexaQuadsAC</td></tr></tbody></table><p><span style="font-weight: bold;">addHexaQuadAB</span> :</p>Les huits sommets sont présents, il manque quatre arêtes verticales ce, cf, df, de.<br>La
difficuté consiste à faire correspondre deux à deux les quatre sommets
de chaque quadrangle sans que les arêtes ne se croisent. La situation
est analogue à <span style="font-weight: bold;">mergeQuads</span> ou <span style="font-weight: bold;">joinQuads</span>, sauf que dans ces cas, on passe
en argument quatre vertex pour déterminer dans ambiguité les sommets
correspondants deux à deux. On a choisi ici
d'automatiser l'association :<br><ul><li>il
existe huit combinaisons permettant d'associer deux à deux les 4
sommets de 2 quadrangles : décalage de 0 à 3 dans un sens puis dans
l'autre. </li><li>Pour chaque combinaison, on calcule la longueur totale des 4 arêtes créées.</li><li>On retient la combinaison qui mène à une longueur minimale.</li></ul>Une fois la combinaison optimale établie :<br><ul><li>Création
des 4 arêtes verticales en fonction des combinaisons, stockées dans tu
tableau tedge[4]. Le premier vertex fourni est celui de la face A. </li><li>Création des 4 quadrangles verticaux.</li><li>Création de l'hexaèdre.</li></ul>Pour créer le&nbsp;i-ème quadrangle vertical : <br><ul><li>l'arête verticale de gauche e_left = tedge[i]</li><li>l'arête verticale de droite e_left = tedge[(i+1) modulo 4]</li><li>l'arête
horizontale basse s'obtient grâce à la fonction Quad::findEdge (v1,
v2). On recherche dans le quadrangle A l'arête dont les 2 sommets sont
les extrémités amont des arêtes e_left et e_right, qui par construction
appartiennent au quadrangle A.</li><li>idem pour&nbsp; l'arête haute ; sauf que ce sont les extrémités aval.</li></ul> <p><span style="font-weight: bold;">addHexaQuadAC</span> :</p><p>Deux
faces présentes A et C, une arête commune ac. Il manque deux sommets
bde et bdf à partir des quels on construit les arêtes manquantes bd,
be, de, bf, df.&nbsp;<br>On doit s'assurer de ma planéité des quadrangles créés. </p><p>La
solution n'est pas unique. Il existe une infinité de sommets pouvant
définir un hexaèdre &nbsp;conforme. On se contente ici d'en choisir une
et de démontrer que l'objet créé est conforme.&nbsp;</p><p>Le point bde (resp bdf) est construit en
sommant les vecteurs ac et ce (resp&nbsp;af et cf), ce qui revient à
définir un parallélogramme. On assure ainsi sa présence dans le plan E
(resp. F). Les faces créées E et F sont donc planaires.</p><p>Pour démontrer la planéité de la face B :<br></p><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><ol><li>(ae , af)&nbsp; coplanaires (donnée)</li><li>be = ae (construction d'un parallèlogramme)</li><li>df = af &nbsp;(idem)</li><li>(1), (2), (3) =&gt; (be, bf) coplanaires </li></ol></td>
</tr>
</tbody>
</table><br>On procéderait de la même manière pour établir que la face D est plane.<br><br>La fonction s'écrit ainsi :<br><ul><li>q_a est le premier quadrangle fourni, q_c le second</li><li>L'edge e_ac est défini qrâce à la strucrure AnaQuads</li><li>On effectue un calcul analogue aux deux extrémités s (amont et aval) de e_ac :</li><ul><li>vx1 = extrémité étudiée de e_ac, vx2 l'autre</li><li>vxa
= sommet adjacent de vx1 sur&nbsp; la face A, différent de vx2. Il est
obtenu en prenant le sommet opposé à vx2 sur la face A. L'indice de vxa
dans qa vaut vx2+2 modulo 4.</li><li>de même, vxc = sommet adjacent de vx1 sur la face&nbsp; C.</li><li>Calcul des coordonnées&nbsp;et&nbsp; création du vertex tv_bdx[s] (x représente la choix entre e et f).</li><li>Création des deux arêtes manquantes&nbsp;te_bx[s] et te_dx[s]</li><li>Création des du quadrangle latéral tq_ef [s]</li></ul><li>Création de l'arête e_bd à partir dses deux vertices de&nbsp; tv_bdx</li><li>Création
du quadrangle D à partir de te_dx[], e_ef, te_dx[1] et de l'arête
opposée à e_ac dans A (fonction Quad::getOpposedEdge(e,n)</li><li>Création du quadrangle B à partir de te_bx[], e_ef, te_bx[1] et de
l'arête opposée à e_ac dans C (fonction Quad::getOpposedEdge(e,n)</li><li>Création de l'hexaèdre</li></ul><p></p><p><img src="red-ball.gif" style="width: 12px; height: 12px;" alt="o">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Création d'un hexaèdre avec trois quadrangles :&nbsp;</span>&nbsp;</p><ul><li>La
classe AnaQuads&nbsp; détecte deux arêtes communes : appel à
addHexaQuadsACD. La face A sera celle qui possède deux arêtes communes,
la face C la suivante, D la derniére.</li><li>La classe AnaQuads&nbsp;
détecte trois arêtes communes : appel à addHexaQuadsACE. Ce cas est
symétrique, la face A sera la première de la liste, C la seconde.</li></ul><p></p><br><table style="text-align: left; width: 90%;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="vertical-align: middle; text-align: center;"><p><img src="Quads_ACD.png" style="width: 282px; height: 226px;" alt="En diedre"></p></td><td style="vertical-align: middle; text-align: center;"><img src="Quads_ACE.png" style="width: 278px; height: 223px;" alt="Trièdre"></td></tr><tr><td style="vertical-align: middle;">addHexa2Quads avec 3 quadrangles&nbsp;disposés en U. <br>Fonction : addHexaQuadsACD</td><td style="vertical-align: middle;">addHexa2Quads avec&nbsp; quadrangles disposés&nbsp; en trièdre<br>Fonction : addHexaQuadsACE</td></tr></tbody></table><p><br></p><p><span style="font-weight: bold;">addHexaQuadACD</span> :</p><p>Tous les sommets sont présents. Il reste à créer :</p><ul><li>Les arêtes be et bf&nbsp;</li><li>Les quadrangles E, B, F en déterminant les arêtes qui les constituent. </li></ul><p>La difficulté est d'identifier clairement les arêtes et les sommets à partir des quadrangles existant :&nbsp;</p><ul><li>q_a est le quadrangle qui possède deux arêtes communes, q_b et q_c les suivants.</li><li>On exploite les indices d'edges communs fournis par <span style="font-weight: bold;">AnaQuads</span>. Rappelons que dans un quadrangle le ième edge est adjacent aux edges i-1 et i+1 et opposé à l'edge i+2.</li><li>e_ac et e_ad sont les intersections de q_a avec q_c et q_d. (nommés ici mais non utilisés dans le programme)</li><li>e_bc est l'arête opposée à e_ac dans q_c,&nbsp;&nbsp;e_bd est l'arête opposée à e_ad dans q_d.</li><li>e_ae
est l'arête suivante de e_ac dans q_a, e_af &nbsp;l'arête précédente.
Ce choix arbitraire&nbsp; détermine les autres dénominations.</li><li>e_ce est l'arête adjacente de e_ac dans q_c qui a un sommet commun (v_ace) avec e_ae.</li><li>e_de est l'arête adjacente de e_ac dans q_d qui a un sommet commun (v_ade) avec e_ae.</li><li>v_acf est le sommet commun à e_af et e_cf</li><li>v_adf est le sommet commun à e_af et e_df</li><li>Création de l'arete e_be &nbsp;à paertir de e_bce et v_bde, puis de l'arête e_bf,</li><li>Créations des quadrangles q_b, q_e, q_f</li><li>Création de l'hexaèdre.</li></ul><p></p><p><span style="font-weight: bold;">addHexaQuadACE</span> :</p><p>Il
est nécessaire de créer le sommet v_bdf. Il est l'intersection des
plans (B, D, F). Chaque plan est défini par trois points présents sur
les autres quadrangles :</p><ul><li>Le plan B est défini par les sommets bcd, bce, bcf . Son vecteur normal norm_b est le produit vectoriel&nbsp;de bc par be.</li><li>Le plan D est défini par les sommets adf, ade, adb. Son vecteur normal norm_d&nbsp; est le produit vectoriel&nbsp;de ac par ae.</li><li>Le
plan F est défini par les sommets adf, acf, bcf.&nbsp; Son vecteur
normal norm_f&nbsp; est le produit vectoriel&nbsp;de ae par ec.</li></ul><p>Soit un plan P défini par un point A et un vecteur normal N. Un point M appartient à P si le produit scalaire N.AM est nul</p><p>On obtient le système d'équations <br></p><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><ol><li>(bdf,bce) . norm_b = 0</li><li>(bdf,ade) . norm_d = 0</li><li>(bdf,acf) . norm_f = 0</li></ol></td>
</tr>
</tbody>
</table>Equivalent à :&nbsp;<br><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><ol><li>&nbsp; &nbsp;norme_b[0]*X + norme_b[1]*Y + norme_b[2]*Z = prod_scalaire (v_bce, norm_b)</li><li>&nbsp;&nbsp; norme_d[0]*X + norme_d[1]*Y + norme_d[2]*Z =&nbsp;prod_scalaire (v_ade, norm_d)</li><li>&nbsp;&nbsp; norme_f[0]*X + norme_f[1]*Y + norme_f[2]*Z =&nbsp;prod_scalaire (v_acf, norm_f)</li></ol></td>
</tr>
</tbody>
</table><br>Ce système de 3 équations à trois inconnues est résolu par la méthode de <span style="font-weight: bold;">Cramer</span> au moyen d'une classe du même nom défini dans le nouveau fichier <span style="font-weight: bold;">HexCramer.hxx.</span> Notons qu'un test unitaire de la classe Cramer existe dans le fichier test_quads.cxx<br style="font-weight: bold;"><p>Une fois le système résolu ; s'il n'est pas régulier on retourne un vecteur nul, la suite est aisée :</p><ul><li>Création du vertex s_bdf à partir des coordonnées calculées</li><li>Détermination
des sommets opposés s_be, s_bcf, s_adf en utilisant la méthode
Edge::commonVertex (edge) sur les arêtes dèja déterminées.</li><li>Création des 3 arêtes manquantes e_bd, e_bf, e_df</li><li>Création des quadrangles manquants q_b, q_d, q_f.</li><li>Création de l'hexaèdre.</li></ul><p></p><p><img src="red-ball.gif" style="width: 12px; height: 12px;" alt="o">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Création d'un hexaèdre avec quatre quadrangles :&nbsp;</span>&nbsp;</p><ul><li>La classe AnaQuads&nbsp;
détecte trois arêtes communes : appel à addHexaQuadsACDE.&nbsp;La face A sera la première trouvée qui en possède trois,
la face E la suivante à trois arêtes,C et D lles deux autres faces à deux arêtes communes.</li><li>La classe AnaQuads&nbsp; détecte quatre arêtes communes : appel à
addHexaQuadsABCD.&nbsp;Ce
cas est
symétrique chaque face possède deux arêtes. La face A sera la première
de la liste, C et D&nbsp;les deux faces sécantes à A, B la dernière.</li></ul><table style="text-align: left; width: 90%;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="vertical-align: middle; text-align: center;"><p><img src="Quads_ABCD.png" style="width: 282px; height: 226px;" alt="En tunnel"></p></td><td style="vertical-align: middle; text-align: center;"><img src="Quads_ACDE.png" style="width: 278px; height: 223px;" alt="En but"></td></tr><tr><td style="vertical-align: middle;">addHexa2Quads avec 4 quadrangles&nbsp; disposés en tunnel. <br>Fonction : addHexaQuadsABCD</td><td style="vertical-align: middle;">addHexa2Quads avec 4 quadrangles&nbsp;disposés en fauteuil. <br>Fonction : addHexaQuadsACDE</td></tr></tbody></table><p><span style="font-weight: bold;">addHexaQuadABCD</span> :</p><p>Le
rôle des quadrangles passés en arguments est symétrique On nommera q_a
le premier trouvé, q_c le premier qui intersecte q_a, q_c le second et
q_d celui qui n'intersecte pas q_a.</p><p>Tous les sommets et arêtes sont présents. Il suffit de créer les deux quadrangles E et F:</p><p>Les problèmes de détermination des variables se traiotent comme dans <span style="font-weight: bold;">addHexaQuadABC</span></p><p><span style="font-weight: bold;">addHexaQuadACDE</span> :</p><p>Le rôle de q_a et qc est symétrique. Ils ont chacun trois arêtes communes avec les autres. q_e et q_f n'en ont que 2.</p><p>Tous les sommets sont présents. Il suffit de créer l'arête e_bf et les deux quasrangles B et F:</p><p>Les edges se déterminent aisément grâce aux indices d'interection fournis par <span style="font-weight: bold;">AnaQuads</span>. Il suffiit de prendre l'opposé :<span style="font-family: monospace;">et à la propriété de la classe Quad : l'indice d'une arête opposée à l'arête i vaut i+2.</span></p><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>&nbsp;&nbsp; int&nbsp;&nbsp; nc_ac = strquads.inter_edge[pos_c][pos_a]; // Nro dans&nbsp; q_c de e_ac<br>&nbsp;&nbsp; int&nbsp;&nbsp; nc_ce = strquads.inter_edge[pos_c][pos_e]; // Nro dans&nbsp; q_c de e_ce<br>&nbsp;&nbsp; int&nbsp;&nbsp; nd_ad = strquads.inter_edge[pos_d][pos_a]; // Nro dans&nbsp; q_d de e_ad<br>&nbsp;&nbsp; int&nbsp;&nbsp; nd_de = strquads.inter_edge[pos_d][pos_e]; // Nro dans&nbsp; q_d de e_de<br>&nbsp;&nbsp; int&nbsp;&nbsp; ne_ae = strquads.inter_edge[pos_e][pos_a]; // Nro dans&nbsp; q_e de e_ae<br><br>&nbsp;&nbsp; Edge* e_af&nbsp; = q_a-&gt;getEdge ((na_ac + 3) MODULO QUAD4);<br>&nbsp;&nbsp; Edge* e_bc&nbsp; = q_c-&gt;getEdge ((nc_ac + 2) MODULO QUAD4);<br>&nbsp;&nbsp; Edge* e_cf&nbsp; = q_c-&gt;getEdge ((nc_ce + 2) MODULO QUAD4);<br>&nbsp;&nbsp; Edge* e_bd&nbsp; = q_d-&gt;getEdge ((nd_ad + 2) MODULO QUAD4);<br>&nbsp;&nbsp; Edge* e_df&nbsp; = q_d-&gt;getEdge ((nd_de + 2) MODULO QUAD4);<br>&nbsp;&nbsp; Edge* e_be&nbsp; = q_e-&gt;getEdge ((ne_ae + 2) MODULO QUAD4);<br><br>&nbsp;&nbsp; Vertex* v_bcf = e_cf-&gt;opposedVertex (e_cf-&gt;commonVertex (e_af));<br>&nbsp;&nbsp; Vertex* v_bdf = e_df-&gt;opposedVertex (e_df-&gt;commonVertex (e_af));</td>
</tr>
</tbody>
</table><p></p><img src="red-ball.gif" style="width: 12px; height: 12px;" alt="o">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Création d'un hexaèdre avec cinq quadrangles :&nbsp;</span> <br><br>Il n'y a pas besoin de dissocier plusieurs cas, le travail est réalisé directement dans la méthode <span style="font-weight: bold;">addHexa5Quads</span>().<br><p style="text-align: center;"><img src="Quads_5.png" style="width: 278px; height: 223px;" alt="En but"></p>Ce cas est assez simple : c'est un hexaèdre auquel il manque la face que l'on convient de nommer B.<br><ul><li>La face q_a est celle qui possède 4 intersections.</li><li>Une
fois son indice qbase déterminé dans AnaQuads, on boucle sur les 4
quadrangles sécants à q_a et on obtient l'arête opposée t_edge[i] et le
quadrangle associé tquad[i]. Les quadrangles q_c, g_d, q_e, q_f se
retrouvent dans le tableau tquad dans un ordre exploitable, le problème
étant symétrique.</li><li>On construit qb à partir des t_edge[i] donnés dans
cet odre :&nbsp; q_b&nbsp; = new Quad (tedge[0], tedge[1], tedge[2],
tedge[3]);</li><li>Enfin l'hexaèdre : hexa = new Hexa (q_a, q_b, tquad[0], tquad[2], tquad[1], tquad[3])</li></ul><p><a href="index.html#DebutPage">Retour au début</a></p><a name="Partie_2.2"></a><p><big><img style="width: 12px; height: 12px;" src="green-ball.gif" alt="o"></big><b><font size="+1"><big> 2.2 Génération d'Hexaèdres par révolution</big></font></b></p><p>Le pont d'entrée dans la classe Document est :<br>

<span style="font-size: 11pt; font-family: Garamond;"></span>
</p><table style="width: 80%; text-align: left; margin-left: auto; margin-right: auto; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td>Elements* revolutionQuads (Quads&amp; start, Vertex* center, Vector* axis, vector&lt;double&gt;&amp; angles);<br></td>
</tr>
</tbody>
</table><br>Avec :<br><ul><li><span style="font-weight: bold;">start</span> est la liste des quadrangles de départ. Ils doivent costituer une surface libre.Rappelons que le type <span style="font-weight: bold;">Quads</span> est équivalent à <span style="font-weight: bold;">vector&lt;Quad*&gt;</span></li><li><span style="font-weight: bold;">center</span> et <span style="font-weight: bold;">axis</span> sont respecttivement le centre et l'axe de la rotation</li><li>le vecteur <span style="font-weight: bold;">angles</span> définit pour chaque incrément l'angle de la rotation.</li></ul><p><a href="index.html#DebutPage">Retour au début</a></p><a name="Partie_2.3"></a><p><big><img style="width: 12px; height: 12px;" src="green-ball.gif" alt="o"></big><b><font size="+1"><big> 2.3 Substitution d'Hexaèdres</big></font></b></p><p></p><p><br> </p><p><a href="index.html#DebutPage">Retour au début</a>
</p><hr width="100%">
<p><a name="Partie_3"></a></p>
<p><img src="blue-ball.gif" alt="o" height="12" width="12"><b><font size="+1">
&nbsp;<big>Partie 3 : Nouvelles fonctions de construction</big> </font></b></p>
Il s'agit de............ <p><a href="index.html#DebutPage">Retour au début</a>
</p><hr width="100%">
<p><a name="Partie_4"></a></p>
<p><img src="blue-ball.gif" alt="o" height="12" width="12"><b><font size="+1">
&nbsp;<big>Partie 4 : Nouvelles fonctions de construction</big> </font></b></p>
Il s'agit de ...........<center><span style="font-style: italic;"><span style="font-weight: bold;"><br><br></span></span>
</center>
<p><a href="index.html#DebutPage">Retour au début</a>
</p><hr width="100%">
<p><a name="Partie_5"></a></p>
<p><img src="blue-ball.gif" alt="o" height="12" width="12"><b><font size="+1">
&nbsp;<big>Partie 5 : Nouvelles fonctions de construction</big> </font></b></p>
Il s'agit de........... 
<p><a href="index.html#DebutPage">Retour au début</a></p>
<hr width="100%">
<p><br></p><br><p><br>
&nbsp;
<br>
&nbsp;
<br>
&nbsp;
<br>
&nbsp;
<br>
&nbsp;
</p>
</body></html>